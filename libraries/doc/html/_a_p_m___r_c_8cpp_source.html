<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ArduPilot Libraries: /home/jgoppert/Projects/ap/libraries/APM_RC/APM_RC.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>/home/jgoppert/Projects/ap/libraries/APM_RC/APM_RC.cpp</h1>  </div>
</div>
<div class="contents">
<a href="_a_p_m___r_c_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">        APM_RC.cpp - Radio Control Library for Ardupilot Mega. Arduino</span>
<a name="l00003"></a>00003 <span class="comment">        Code by Jordi Muñoz and Jose Julio. DIYDrones.com</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">        This library is free software; you can redistribute it and/or</span>
<a name="l00006"></a>00006 <span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
<a name="l00007"></a>00007 <span class="comment">    License as published by the Free Software Foundation; either</span>
<a name="l00008"></a>00008 <span class="comment">    version 2.1 of the License, or (at your option) any later version.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">        RC Input : PPM signal on IC4 pin</span>
<a name="l00011"></a>00011 <span class="comment">        RC Output : 11 Servo outputs (standard 20ms frame)</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">        Methods:</span>
<a name="l00014"></a>00014 <span class="comment">                Init() : Initialization of interrupts an Timers</span>
<a name="l00015"></a>00015 <span class="comment">                OutpuCh(ch,pwm) : Output value to servos (range : 900-2100us) ch=0..10</span>
<a name="l00016"></a>00016 <span class="comment">                InputCh(ch) : Read a channel input value.  ch=0..7</span>
<a name="l00017"></a>00017 <span class="comment">                GetState() : Returns the state of the input. 1 =&gt; New radio frame to process</span>
<a name="l00018"></a>00018 <span class="comment">                             Automatically resets when we call InputCh to read channels</span>
<a name="l00019"></a>00019 <span class="comment">                </span>
<a name="l00020"></a>00020 <span class="comment">*/</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="_a_p_m___r_c_8h.html">APM_RC.h</a>&quot;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="_w_program_8h.html">WProgram.h</a>&quot;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#if !defined(__AVR_ATmega1280__) &amp;&amp; !defined(__AVR_ATmega2560__)</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor"># error Please check the Tools/Board menu to ensure you have selected Arduino Mega as your target.</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00030"></a>00030 <span class="comment">// Variable definition for Input Capture interrupt</span>
<a name="l00031"></a>00031 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ICR4_old;
<a name="l00032"></a>00032 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> PPM_Counter=0;
<a name="l00033"></a>00033 <span class="keyword">volatile</span> uint16_t PWM_RAW[8] = {2400,2400,2400,2400,2400,2400,2400,2400};
<a name="l00034"></a>00034 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> radio_status=0;
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="comment">/****************************************************</span>
<a name="l00037"></a>00037 <span class="comment">   Input Capture Interrupt ICP4 =&gt; PPM signal read</span>
<a name="l00038"></a>00038 <span class="comment"> ****************************************************/</span>
<a name="l00039"></a>00039 <a class="code" href="_a_p___a_d_c___a_d_s7844_8cpp.html#a7cfcbe42bd266750aeb6e5d71e5ea479">ISR</a>(TIMER4_CAPT_vect)  
<a name="l00040"></a>00040 {
<a name="l00041"></a>00041   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Pulse;
<a name="l00042"></a>00042   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Pulse_Width;
<a name="l00043"></a>00043   
<a name="l00044"></a>00044   Pulse=ICR4;
<a name="l00045"></a>00045   <span class="keywordflow">if</span> (Pulse&lt;ICR4_old)     <span class="comment">// Take care of the overflow of Timer4 (TOP=40000)</span>
<a name="l00046"></a>00046     Pulse_Width=(Pulse + 40000)-ICR4_old;  <span class="comment">//Calculating pulse </span>
<a name="l00047"></a>00047   <span class="keywordflow">else</span>
<a name="l00048"></a>00048     Pulse_Width=Pulse-ICR4_old;            <span class="comment">//Calculating pulse </span>
<a name="l00049"></a>00049   <span class="keywordflow">if</span> (Pulse_Width&gt;8000)   <span class="comment">// SYNC pulse?</span>
<a name="l00050"></a>00050     PPM_Counter=0;
<a name="l00051"></a>00051   <span class="keywordflow">else</span>
<a name="l00052"></a>00052     {
<a name="l00053"></a>00053     PPM_Counter &amp;= 0x07;  <span class="comment">// For safety only (limit PPM_Counter to 7)</span>
<a name="l00054"></a>00054     PWM_RAW[PPM_Counter++]=Pulse_Width;  <span class="comment">//Saving pulse. </span>
<a name="l00055"></a>00055     <span class="keywordflow">if</span> (PPM_Counter &gt;= <a class="code" href="_a_p_m___r_c_8h.html#ae5597ce31d23d11493e6e674fe257d73">NUM_CHANNELS</a>)
<a name="l00056"></a>00056       radio_status = 1;
<a name="l00057"></a>00057     }
<a name="l00058"></a>00058   ICR4_old = Pulse;
<a name="l00059"></a>00059 }
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="comment">// Constructors ////////////////////////////////////////////////////////////////</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <a class="code" href="class_a_p_m___r_c___class.html#a884f9e7b184586aa39e3871065119e46">APM_RC_Class::APM_RC_Class</a>()
<a name="l00065"></a>00065 {
<a name="l00066"></a>00066 }
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="comment">// Public Methods //////////////////////////////////////////////////////////////</span>
<a name="l00069"></a>00069 <span class="keywordtype">void</span> <a class="code" href="class_a_p_m___r_c___class.html#ab5f29eed597255bc0ee5a9b84b5c294f">APM_RC_Class::Init</a>(<span class="keywordtype">void</span>)
<a name="l00070"></a>00070 {
<a name="l00071"></a>00071   <span class="comment">// Init PWM Timer 1</span>
<a name="l00072"></a>00072   pinMode(11,OUTPUT); <span class="comment">//     (PB5/OC1A)</span>
<a name="l00073"></a>00073   pinMode(12,OUTPUT); <span class="comment">//OUT2 (PB6/OC1B)</span>
<a name="l00074"></a>00074   pinMode(13,OUTPUT); <span class="comment">//OUT3 (PB7/OC1C)</span>
<a name="l00075"></a>00075 
<a name="l00076"></a>00076   <span class="comment">//Remember the registers not declared here remains zero by default... </span>
<a name="l00077"></a>00077   TCCR1A =((1&lt;&lt;WGM11)|(1&lt;&lt;COM1A1)|(1&lt;&lt;COM1B1)|(1&lt;&lt;COM1C1)); <span class="comment">//Please read page 131 of DataSheet, we are changing the registers settings of WGM11,COM1B1,COM1A1 to 1 thats all... </span>
<a name="l00078"></a>00078   TCCR1B = (1&lt;&lt;WGM13)|(1&lt;&lt;WGM12)|(1&lt;&lt;CS11); <span class="comment">//Prescaler set to 8, that give us a resolution of 0.5us, read page 134 of data sheet</span>
<a name="l00079"></a>00079   OCR1A = 3000; <span class="comment">//PB5, none</span>
<a name="l00080"></a>00080   <span class="comment">//OCR1B = 3000; //PB6, OUT2</span>
<a name="l00081"></a>00081   <span class="comment">//OCR1C = 3000; //PB7  OUT3</span>
<a name="l00082"></a>00082   ICR1 = 40000; <span class="comment">//50hz freq...Datasheet says  (system_freq/prescaler)/target frequency. So (16000000hz/8)/50hz=40000,</span>
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   <span class="comment">// Init PWM Timer 3</span>
<a name="l00085"></a>00085   pinMode(2,OUTPUT); <span class="comment">//OUT7 (PE4/OC3B)</span>
<a name="l00086"></a>00086   pinMode(3,OUTPUT); <span class="comment">//OUT6 (PE5/OC3C)</span>
<a name="l00087"></a>00087   pinMode(4,OUTPUT); <span class="comment">//     (PE3/OC3A)</span>
<a name="l00088"></a>00088   TCCR3A =((1&lt;&lt;WGM31)|(1&lt;&lt;COM3A1)|(1&lt;&lt;COM3B1)|(1&lt;&lt;COM3C1));
<a name="l00089"></a>00089   TCCR3B = (1&lt;&lt;WGM33)|(1&lt;&lt;WGM32)|(1&lt;&lt;CS31); 
<a name="l00090"></a>00090   OCR3A = 3000; <span class="comment">//PE3, NONE</span>
<a name="l00091"></a>00091   OCR3B = 3000; <span class="comment">//PE4, OUT7</span>
<a name="l00092"></a>00092   OCR3C = 3000; <span class="comment">//PE5, OUT6</span>
<a name="l00093"></a>00093   ICR3 = 40000; <span class="comment">//50hz freq</span>
<a name="l00094"></a>00094 
<a name="l00095"></a>00095   <span class="comment">// Init PWM Timer 5</span>
<a name="l00096"></a>00096   pinMode(44,OUTPUT);  <span class="comment">//OUT1 (PL5/OC5C)</span>
<a name="l00097"></a>00097   pinMode(45,OUTPUT);  <span class="comment">//OUT0 (PL4/OC5B)</span>
<a name="l00098"></a>00098   pinMode(46,OUTPUT);  <span class="comment">//     (PL3/OC5A)</span>
<a name="l00099"></a>00099   
<a name="l00100"></a>00100   TCCR5A =((1&lt;&lt;WGM51)|(1&lt;&lt;COM5A1)|(1&lt;&lt;COM5B1)|(1&lt;&lt;COM5C1)); 
<a name="l00101"></a>00101   TCCR5B = (1&lt;&lt;WGM53)|(1&lt;&lt;WGM52)|(1&lt;&lt;CS51);
<a name="l00102"></a>00102   OCR5A = 3000; <span class="comment">//PL3, </span>
<a name="l00103"></a>00103   <span class="comment">//OCR5B = 3000; //PL4, OUT0</span>
<a name="l00104"></a>00104   <span class="comment">//OCR5C = 3000; //PL5, OUT1</span>
<a name="l00105"></a>00105   ICR5 = 40000; <span class="comment">//50hz freq</span>
<a name="l00106"></a>00106 
<a name="l00107"></a>00107   <span class="comment">// Init PPM input and PWM Timer 4</span>
<a name="l00108"></a>00108   pinMode(49, INPUT);  <span class="comment">// ICP4 pin (PL0) (PPM input)</span>
<a name="l00109"></a>00109   pinMode(7,OUTPUT);   <span class="comment">//OUT5 (PH4/OC4B)</span>
<a name="l00110"></a>00110   pinMode(8,OUTPUT);   <span class="comment">//OUT4 (PH5/OC4C)</span>
<a name="l00111"></a>00111       
<a name="l00112"></a>00112   TCCR4A =((1&lt;&lt;WGM40)|(1&lt;&lt;WGM41)|(1&lt;&lt;COM4C1)|(1&lt;&lt;COM4B1)|(1&lt;&lt;COM4A1));  
<a name="l00113"></a>00113   <span class="comment">//Prescaler set to 8, that give us a resolution of 0.5us</span>
<a name="l00114"></a>00114   <span class="comment">// Input Capture rising edge</span>
<a name="l00115"></a>00115   TCCR4B = ((1&lt;&lt;WGM43)|(1&lt;&lt;WGM42)|(1&lt;&lt;CS41)|(1&lt;&lt;ICES4));
<a name="l00116"></a>00116   
<a name="l00117"></a>00117   OCR4A = 40000; 
<a name="l00118"></a>00118   OCR4B = 3000; <span class="comment">//PH4, OUT5</span>
<a name="l00119"></a>00119   OCR4C = 3000; <span class="comment">//PH5, OUT4</span>
<a name="l00120"></a>00120  
<a name="l00121"></a>00121   <span class="comment">//TCCR4B |=(1&lt;&lt;ICES4); //Changing edge detector (rising edge). </span>
<a name="l00122"></a>00122   <span class="comment">//TCCR4B &amp;=(~(1&lt;&lt;ICES4)); //Changing edge detector. (falling edge)</span>
<a name="l00123"></a>00123   TIMSK4 |= (1&lt;&lt;ICIE4); <span class="comment">// Enable Input Capture interrupt. Timer interrupt mask</span>
<a name="l00124"></a>00124 }
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="keywordtype">void</span> <a class="code" href="class_a_p_m___r_c___class.html#a5ab1f315d99872c03f5cb496eca70f72">APM_RC_Class::OutputCh</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ch, uint16_t pwm)
<a name="l00127"></a>00127 {
<a name="l00128"></a>00128   pwm=constrain(pwm,<a class="code" href="_a_p_m___r_c_8h.html#a5e387ac2b738a047d6b1f2833c0baa3c">MIN_PULSEWIDTH</a>,<a class="code" href="_a_p_m___r_c_8h.html#a4112e018a7167fb1633bd93f022778ac">MAX_PULSEWIDTH</a>);
<a name="l00129"></a>00129   pwm&lt;&lt;=1;   <span class="comment">// pwm*2;</span>
<a name="l00130"></a>00130  
<a name="l00131"></a>00131  <span class="keywordflow">switch</span>(ch)
<a name="l00132"></a>00132   {
<a name="l00133"></a>00133     <span class="keywordflow">case</span> 0:  OCR5B=pwm; <span class="keywordflow">break</span>;  <span class="comment">//ch0</span>
<a name="l00134"></a>00134     <span class="keywordflow">case</span> 1:  OCR5C=pwm; <span class="keywordflow">break</span>;  <span class="comment">//ch1</span>
<a name="l00135"></a>00135     <span class="keywordflow">case</span> 2:  OCR1B=pwm; <span class="keywordflow">break</span>;  <span class="comment">//ch2</span>
<a name="l00136"></a>00136     <span class="keywordflow">case</span> 3:  OCR1C=pwm; <span class="keywordflow">break</span>;  <span class="comment">//ch3</span>
<a name="l00137"></a>00137     <span class="keywordflow">case</span> 4:  OCR4C=pwm; <span class="keywordflow">break</span>;  <span class="comment">//ch4</span>
<a name="l00138"></a>00138     <span class="keywordflow">case</span> 5:  OCR4B=pwm; <span class="keywordflow">break</span>;  <span class="comment">//ch5</span>
<a name="l00139"></a>00139     <span class="keywordflow">case</span> 6:  OCR3C=pwm; <span class="keywordflow">break</span>;  <span class="comment">//ch6</span>
<a name="l00140"></a>00140     <span class="keywordflow">case</span> 7:  OCR3B=pwm; <span class="keywordflow">break</span>;  <span class="comment">//ch7</span>
<a name="l00141"></a>00141     <span class="keywordflow">case</span> 8:  OCR5A=pwm; <span class="keywordflow">break</span>;  <span class="comment">//ch8,  PL3</span>
<a name="l00142"></a>00142     <span class="keywordflow">case</span> 9:  OCR1A=pwm; <span class="keywordflow">break</span>;  <span class="comment">//ch9,  PB5</span>
<a name="l00143"></a>00143     <span class="keywordflow">case</span> 10: OCR3A=pwm; <span class="keywordflow">break</span>;  <span class="comment">//ch10, PE3</span>
<a name="l00144"></a>00144   } 
<a name="l00145"></a>00145 }
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 uint16_t <a class="code" href="class_a_p_m___r_c___class.html#a32157ead4d981921ced73e9ca96b2228">APM_RC_Class::InputCh</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ch)
<a name="l00148"></a>00148 {
<a name="l00149"></a>00149   uint16_t result;
<a name="l00150"></a>00150   uint16_t result2;
<a name="l00151"></a>00151   
<a name="l00152"></a>00152   <span class="comment">// Because servo pulse variables are 16 bits and the interrupts are running values could be corrupted.</span>
<a name="l00153"></a>00153   <span class="comment">// We dont want to stop interrupts to read radio channels so we have to do two readings to be sure that the value is correct...</span>
<a name="l00154"></a>00154   result =  PWM_RAW[ch]&gt;&gt;1;  <span class="comment">// Because timer runs at 0.5us we need to do value/2</span>
<a name="l00155"></a>00155   result2 =  PWM_RAW[ch]&gt;&gt;1;
<a name="l00156"></a>00156   <span class="keywordflow">if</span> (result != result2)
<a name="l00157"></a>00157     result =  PWM_RAW[ch]&gt;&gt;1;   <span class="comment">// if the results are different we make a third reading (this should be fine)</span>
<a name="l00158"></a>00158   
<a name="l00159"></a>00159   <span class="comment">// Limit values to a valid range</span>
<a name="l00160"></a>00160   result = constrain(result,<a class="code" href="_a_p_m___r_c_8h.html#a5e387ac2b738a047d6b1f2833c0baa3c">MIN_PULSEWIDTH</a>,<a class="code" href="_a_p_m___r_c_8h.html#a4112e018a7167fb1633bd93f022778ac">MAX_PULSEWIDTH</a>);
<a name="l00161"></a>00161   radio_status=0; <span class="comment">// Radio channel read</span>
<a name="l00162"></a>00162   <span class="keywordflow">return</span>(result);
<a name="l00163"></a>00163 }
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="class_a_p_m___r_c___class.html#a3efab8ea22fa083532784afe316e3115">APM_RC_Class::GetState</a>(<span class="keywordtype">void</span>)
<a name="l00166"></a>00166 {
<a name="l00167"></a>00167   <span class="keywordflow">return</span>(radio_status);
<a name="l00168"></a>00168 }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <span class="comment">// InstantPWM implementation</span>
<a name="l00171"></a>00171 <span class="comment">// This function forces the PWM output (reset PWM) on Out0 and Out1 (Timer5). For quadcopters use</span>
<a name="l00172"></a>00172 <span class="keywordtype">void</span> <a class="code" href="class_a_p_m___r_c___class.html#a87004883ef9e915b22b128b670313e6e">APM_RC_Class::Force_Out0_Out1</a>(<span class="keywordtype">void</span>)
<a name="l00173"></a>00173 {
<a name="l00174"></a>00174   <span class="keywordflow">if</span> (TCNT5&gt;5000)  <span class="comment">// We take care that there are not a pulse in the output</span>
<a name="l00175"></a>00175     TCNT5=39990;   <span class="comment">// This forces the PWM output to reset in 5us (10 counts of 0.5us). The counter resets at 40000</span>
<a name="l00176"></a>00176 }
<a name="l00177"></a>00177 <span class="comment">// This function forces the PWM output (reset PWM) on Out2 and Out3 (Timer1). For quadcopters use</span>
<a name="l00178"></a>00178 <span class="keywordtype">void</span> <a class="code" href="class_a_p_m___r_c___class.html#a20ad8c9bec4fafd9106220d4ebac3ea3">APM_RC_Class::Force_Out2_Out3</a>(<span class="keywordtype">void</span>)
<a name="l00179"></a>00179 {
<a name="l00180"></a>00180   <span class="keywordflow">if</span> (TCNT1&gt;5000)
<a name="l00181"></a>00181     TCNT1=39990;
<a name="l00182"></a>00182 }
<a name="l00183"></a>00183 <span class="comment">// This function forces the PWM output (reset PWM) on Out6 and Out7 (Timer3). For quadcopters use</span>
<a name="l00184"></a>00184 <span class="keywordtype">void</span> <a class="code" href="class_a_p_m___r_c___class.html#a20d31a9ca0bbd26891a41f2cfb84de6e">APM_RC_Class::Force_Out6_Out7</a>(<span class="keywordtype">void</span>)
<a name="l00185"></a>00185 {
<a name="l00186"></a>00186   <span class="keywordflow">if</span> (TCNT3&gt;5000)
<a name="l00187"></a>00187     TCNT3=39990;
<a name="l00188"></a>00188 }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="comment">// make one instance for the user to use</span>
<a name="l00191"></a>00191 <a class="code" href="class_a_p_m___r_c___class.html">APM_RC_Class</a> <a class="code" href="_a_p_m___r_c_8h.html#aa3b2e28948f56cfd1b336bb6c7ce4a3c">APM_RC</a>;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="preprocessor">#endif // defined(ATMega1280)</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Dec 26 2010 19:58:34 for ArduPilot Libraries by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
